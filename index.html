<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kick Shuffler Prototype</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; }
        body { background: #121212; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; position: relative; overflow-x: hidden; -webkit-font-smoothing: antialiased; }
        .volume-container { position: fixed; right: 30px; top: 50%; transform: translate3d(0,-50%,0); display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 1000; will-change: transform; }
        .volume-slider-wrapper { height: 300px; display: flex; align-items: center; }
        #volume-slider { -webkit-appearance: slider-vertical; writing-mode: bt-lr; width: 8px; height: 300px; background: rgba(255, 0, 255, 0.2); border-radius: 10px; outline: none; cursor: pointer; touch-action: none; }
        #volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 25px; height: 25px; border-radius: 50%; background: #ff00ff; cursor: pointer; box-shadow: 0 0 15px #ff00ff; }
        #volume-slider::-moz-range-thumb { width: 25px; height: 25px; border-radius: 50%; background: #ff00ff; cursor: pointer; border: none; box-shadow: 0 0 15px #ff00ff; }
        .volume-label { color: #ff00ff; font-size: 0.9rem; font-weight: bold; writing-mode: vertical-rl; text-orientation: mixed; letter-spacing: 2px; }
        .volume-display { color: #ff00ff; font-weight: bold; font-size: 1.5rem; text-shadow: 0 0 10px #ff00ff; }
        .volume-icon { width: 40px; height: 40px; border: 2px solid #ff00ff; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 10px #ff00ff; background: rgba(255, 0, 255, 0.1); }
        #status { color: #00ffcc; margin-bottom: 20px; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; }
        .icon-container { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #voice-icon { width: 80px; height: 80px; border: 3px solid #00ffcc; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 15px #00ffcc; cursor: pointer; background: rgba(0, 255, 204, 0.1); transition: transform 0.2s ease, background 0.2s ease; will-change: transform; transform: translate3d(0,0,0); touch-action: manipulation; }
        @media (hover: hover) { #voice-icon:hover { background: rgba(0, 255, 204, 0.3); transform: translate3d(0,0,0) scale(1.05); } }
        #voice-icon.active { background: rgba(0, 255, 204, 0.3); box-shadow: 0 0 25px #00ffcc; }
        .drum-effects-container { position: relative; display: flex; align-items: center; justify-content: center; gap: 40px; }
        .effect-btn { width: 70px; height: 70px; border: 3px solid #ffaa00; border-radius: 50%; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 0 15px #ffaa00; cursor: pointer; background: rgba(255, 170, 0, 0.1); transition: transform 0.2s ease, background 0.2s ease; font-size: 0.7rem; color: #ffaa00; font-weight: bold; will-change: transform; transform: translate3d(0,0,0); touch-action: manipulation; }
        @media (hover: hover) { .effect-btn:hover { background: rgba(255, 170, 0, 0.3); transform: translate3d(0,0,0) scale(1.05); } }
        .effect-btn.active { background: rgba(255, 170, 0, 0.4); box-shadow: 0 0 25px #ffaa00; border-color: #ffcc00; }
        .effect-btn svg { margin-bottom: 3px; }
        #drum-icon { width: 200px; height: 200px; border: 4px solid #ff00ff; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 20px #ff00ff; transition: transform 0.1s ease; cursor: pointer; will-change: transform; transform: translate3d(0,0,0); touch-action: manipulation; }
        #drum-icon.pulse { transform: translate3d(0,0,0) scale(1.1); background: rgba(255, 0, 255, 0.2); }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: rgba(255, 0, 255, 0.2); }
            100% { transform: scale(1); }
        }
        #drum-icon.pulsing { animation: pulse 0.1s ease-out; will-change: transform; }
        h1 { margin-top: 30px; font-size: 1.2rem; color: #aaa; }
        .controls { margin-top: 40px; display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        button { background: transparent; border: 1px solid #fff; color: #fff; padding: 10px 20px; border-radius: 20px; cursor: pointer; transition: background 0.2s ease, color 0.2s ease; touch-action: manipulation; }
        @media (hover: hover) { button:hover { background: #fff; color: #000; } }
        .tempo-control { margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .tempo-control input { width: 200px; }
        .tempo-control label { color: #aaa; font-size: 0.9rem; }
        #tempo-display { color: #00ffcc; font-weight: bold; font-size: 1.2rem; }
        .effects-control { margin-top: 20px; display: flex; gap: 30px; align-items: flex-start; justify-content: center; }
        .effect-slider-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .effect-slider-group label { color: #ffaa00; font-size: 0.85rem; font-weight: bold; }
        .effect-slider-group input { width: 150px; }
        .slider-value { color: #ffaa00; font-weight: bold; font-size: 1rem; }
        button.active { background: #00ffcc; color: #000; border-color: #00ffcc; }
        .instructions-btn { background: rgba(255, 255, 255, 0.05); border: 1px solid #666; color: #aaa; padding: 5px 15px; font-size: 0.8rem; border-radius: 15px; cursor: pointer; margin-top: 10px; touch-action: manipulation; }
        @media (hover: hover) { .instructions-btn:hover { background: rgba(255, 255, 255, 0.1); color: #fff; } }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            body { overflow-x: hidden; }
            .volume-container { right: 10px; gap: 8px; }
            .volume-slider-wrapper { height: 200px; }
            #volume-slider { height: 200px; }
            .volume-display { font-size: 1rem; }
            .volume-icon { width: 30px; height: 30px; }
            .volume-icon svg { width: 18px; height: 18px; }
            .volume-label { font-size: 0.7rem; }
            #status { font-size: 0.8rem; margin-bottom: 15px; }
            .icon-container { gap: 10px; }
            #voice-icon { width: 60px; height: 60px; }
            #voice-icon svg { width: 30px; height: 30px; }
            .drum-effects-container { gap: 20px; }
            #drum-icon { width: 150px; height: 150px; }
            #drum-icon svg { width: 75px; height: 75px; }
            .effect-btn { width: 55px; height: 55px; font-size: 0.6rem; }
            .effect-btn svg { width: 24px; height: 24px; }
            h1 { font-size: 1rem; margin-top: 20px; }
            .instructions-btn { font-size: 0.7rem; padding: 4px 12px; margin-top: 8px; }
            .controls { margin-top: 25px; gap: 12px; }
            button { padding: 8px 16px; font-size: 0.85rem; }
            .tempo-control { margin-top: 15px; gap: 8px; }
            .tempo-control input { width: 150px; }
            #tempo-display { font-size: 1rem; }
            .tempo-control label { font-size: 0.8rem; }
            .effects-control { margin-top: 15px; gap: 20px; flex-direction: column; }
            .effect-slider-group input { width: 120px; }
            .effect-slider-group label { font-size: 0.75rem; }
            .slider-value { font-size: 0.85rem; }
        }
        
        @media (max-width: 480px) {
            .volume-container { right: 5px; }
            .volume-slider-wrapper { height: 150px; }
            #volume-slider { height: 150px; width: 6px; }
            #volume-slider::-webkit-slider-thumb { width: 20px; height: 20px; }
            #volume-slider::-moz-range-thumb { width: 20px; height: 20px; }
            #drum-icon { width: 120px; height: 120px; }
            #drum-icon svg { width: 60px; height: 60px; }
            .drum-effects-container { gap: 15px; }
            .effect-btn { width: 45px; height: 45px; font-size: 0.5rem; }
            .effect-btn svg { width: 20px; height: 20px; }
            #voice-icon { width: 50px; height: 50px; }
            #voice-icon svg { width: 25px; height: 25px; }
            h1 { font-size: 0.85rem; max-width: 90vw; text-align: center; }
            .controls { gap: 10px; }
            button { padding: 7px 14px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>

    <div class="volume-container">
        <div class="volume-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ff00ff" stroke-width="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        </div>
        <div class="volume-display" id="volume-display">100%</div>
        <div class="volume-slider-wrapper">
            <input type="range" id="volume-slider" min="0" max="100" value="100" orient="vertical" oninput="setVolume(this.value)">
        </div>
        <div class="volume-label">VOLUME</div>
    </div>

    <div id="status">Voice Standby</div>
    
    <div class="icon-container">
        <div id="voice-icon" onclick="toggleVoice()">
            <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#00ffcc" stroke-width="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        </div>
        <div class="drum-effects-container">
            <div class="effect-btn" id="reverb-btn" onclick="toggleReverb()">
                <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="#ffaa00" stroke-width="2">
                    <path d="M12 2v20M2 12h20M17.5 6.5l-11 11M6.5 6.5l11 11"></path>
                </svg>
                <span>REVERB</span>
            </div>
            <div id="drum-icon" onclick="playCurrentKick()">
                <svg width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="#ff00ff" stroke-width="1.5">
                    <ellipse cx="12" cy="9" rx="10" ry="5"></ellipse>
                    <path d="M2 9v6c0 2.5 4.5 5 10 5s10-2.5 10-5V9"></path>
                    <path d="M7 12.5v3M12 14v3M17 12.5v3"></path>
                </svg>
            </div>
            <div class="effect-btn" id="distortion-btn" onclick="toggleDistortion()">
                <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="#ffaa00" stroke-width="2">
                    <path d="M3 12 L6 8 L9 16 L12 4 L15 14 L18 8 L21 12"></path>
                </svg>
                <span>DISTORT</span>
            </div>
        </div>
    </div>

    <h1 id="filename">READY TO SHUFFLE</h1>

    <button class="instructions-btn" onclick="showVoiceInstructions()">Voice Commands</button>

    <div class="controls">
        <button id="loop-btn" onclick="toggleLoop()">Start Loop</button>
        <button onclick="shuffleKick()">Shuffle Kick</button>
        <button onclick="downloadKick()">Download Kick</button>
        <button onclick="sendEmail()">Email This Kick</button>
    </div>

    <div class="tempo-control">
        <label for="tempo-slider">Tempo (BPM)</label>
        <div id="tempo-display">120</div>
        <input type="range" id="tempo-slider" min="60" max="200" value="120" oninput="setTempo(this.value)">
    </div>

    <div class="effects-control">
        <div class="effect-slider-group">
            <label for="reverb-slider">Reverb Amount</label>
            <div class="slider-value" id="reverb-value">50%</div>
            <input type="range" id="reverb-slider" min="0" max="100" value="50" oninput="setReverbAmount(this.value)">
        </div>
        <div class="effect-slider-group">
            <label for="distortion-slider">Distortion Amount</label>
            <div class="slider-value" id="distortion-value">50%</div>
            <input type="range" id="distortion-slider" min="0" max="100" value="50" oninput="setDistortionAmount(this.value)">
        </div>
    </div>

    <script>
        // 1. Define your library (Make sure these filenames match your folder)
const kickLibrary = [
    "StudioBrootle House Kicks-01.wav",
    "StudioBrootle House Kicks-02.wav",
    "StudioBrootle House Kicks-03.wav",
    "StudioBrootle House Kicks-04.wav",
    "StudioBrootle House Kicks-05.wav",
    "StudioBrootle House Kicks-06.wav",
    "StudioBrootle House Kicks-07.wav",
    "StudioBrootle House Kicks-08.wav",
    "StudioBrootle House Kicks-09.wav",
    "StudioBrootle House Kicks-10.wav",
    "StudioBrootle House Kicks-11.wav",
    "StudioBrootle House Kicks-12.wav",
    "StudioBrootle House Kicks-13.wav",
    "StudioBrootle House Kicks-14.wav",
    "StudioBrootle House Kicks-15.wav",
    "StudioBrootle House Kicks-16.wav",
    "StudioBrootle House Kicks-17.wav",
    "StudioBrootle House Kicks-18.wav",
    "StudioBrootle House Kicks-19.wav",
    "StudioBrootle House Kicks-20.wav"
];

let currentKick = "";
let isLooping = false;
let loopInterval = null;
let bpm = 120;
let recognition = null;
let isVoiceActive = false;
let audioPlayer = new Audio(); // Reuse single audio object
audioPlayer.preload = 'auto';
let lastBeatTime = 0;
let beatDrift = 0;
let lastInteraction = 0;
const DEBOUNCE_DELAY = 150;

// Web Audio API setup
let audioContext = null;
let sourceNode = null;
let gainNode = null;
let distortionNode = null;
let convolverNode = null;
let reverbEnabled = false;
let distortionEnabled = false;
let reverbAmount = 50;
let distortionAmount = 50;
let masterVolume = 1.0;

function shuffleKick() {
    const now = Date.now();
    if (now - lastInteraction < DEBOUNCE_DELAY) return;
    lastInteraction = now;
    
    const drum = document.getElementById('drum-icon');
    const fileText = document.getElementById('filename');
    
    // Select random file
    currentKick = kickLibrary[Math.floor(Math.random() * kickLibrary.length)];
    fileText.textContent = currentKick.toUpperCase();

    // Play the actual audio file
    if (reverbEnabled || distortionEnabled) {
        playWithEffects(currentKick);
    } else {
        const audio = new Audio(currentKick);
        audio.volume = masterVolume;
        audio.play().catch(err => {
            console.error('Audio playback failed:', err);
            document.getElementById('status').textContent = 'Tap to play';
        });
    }

    // Visual pulse using CSS animation
    drum.classList.remove('pulsing');
    void drum.offsetWidth; // Force reflow
    drum.classList.add('pulsing');
}

function playCurrentKick() {
    const now = Date.now();
    if (now - lastInteraction < DEBOUNCE_DELAY) return;
    lastInteraction = now;
    
    if (!currentKick) {
        shuffleKick();
        return;
    }
    
    const drum = document.getElementById('drum-icon');
    
    if (reverbEnabled || distortionEnabled) {
        playWithEffects(currentKick);
    } else {
        const audio = new Audio(currentKick);
        audio.volume = masterVolume;
        audio.play().catch(err => {
            console.error('Audio playback failed:', err);
            document.getElementById('status').textContent = 'Tap to play';
        });
    }
    
    // Visual pulse using CSS animation
    drum.classList.remove('pulsing');
    void drum.offsetWidth; // Force reflow
    drum.classList.add('pulsing');
}

function playWithEffects(audioFile) {
    // Initialize audio context if not already done
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (!audioContext) {
        // Use lower sample rate on mobile for better performance
        const contextOptions = isMobile ? { sampleRate: 22050 } : {};
        audioContext = new (window.AudioContext || window.webkitAudioContext)(contextOptions);
        
        // Create nodes
        gainNode = audioContext.createGain();
        distortionNode = audioContext.createWaveShaper();
        convolverNode = audioContext.createConvolver();
    }
    
    // Update distortion curve with current amount
    distortionNode.curve = makeDistortionCurve(distortionAmount * 10);
    distortionNode.oversample = 'none'; // No oversampling for performance
    
    // Update reverb impulse with current amount
    createReverbImpulse(reverbAmount / 100);
    
    // Fetch and decode audio
    fetch(audioFile)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
            // Create source
            if (sourceNode) {
                sourceNode.stop();
            }
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            
            // Create dry/wet paths
            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            
            // Connect dry path (direct)
            sourceNode.connect(dryGain);
            dryGain.connect(gainNode);
            
            // Connect wet path (with effects)
            let wetNode = sourceNode;
            
            if (distortionEnabled) {
                wetNode.connect(distortionNode);
                wetNode = distortionNode;
            }
            
            if (reverbEnabled) {
                wetNode.connect(convolverNode);
                wetNode = convolverNode;
            }
            
            wetNode.connect(wetGain);
            wetGain.connect(gainNode);
            
            // Set dry/wet mix based on effects
            const totalEffects = (reverbEnabled ? reverbAmount : 0) + (distortionEnabled ? distortionAmount : 0);
            const wetMix = Math.min(totalEffects / 100, 1);
            dryGain.gain.value = (1 - (wetMix * 0.5)) * masterVolume;
            wetGain.gain.value = wetMix * 0.7 * masterVolume;
            
            gainNode.gain.value = masterVolume;
            gainNode.connect(audioContext.destination);
            
            sourceNode.start(0);
        })
        .catch(err => {
            console.error('Audio playback with effects failed:', err);
            document.getElementById('status').textContent = 'Effects failed';
        });
}

function makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    // Ultra-low samples on mobile for maximum performance
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const n_samples = isMobile ? 2048 : 22050; // Minimal sample count
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    
    for (let i = 0; i < n_samples; i++) {
        const x = (i * 2) / n_samples - 1;
        curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
    }
    return curve;
}

function createReverbImpulse(intensity = 0.5) {
    const sampleRate = audioContext.sampleRate;
    // Ultra-short reverb and mono on mobile for maximum performance
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const reverbLength = isMobile ? (0.1 + intensity * 0.2) : (1 + intensity * 2); // Extremely short on mobile
    const length = sampleRate * reverbLength;
    const channels = isMobile ? 1 : 2; // Mono on mobile, stereo on desktop
    const impulse = audioContext.createBuffer(channels, length, sampleRate);
    const impulseL = impulse.getChannelData(0);
    
    for (let i = 0; i < length; i++) {
        const n = length - i;
        const decay = Math.pow(n / length, 3 + (1 - intensity)); // Faster decay on mobile
        impulseL[i] = (Math.random() * 2 - 1) * decay * intensity;
    }
    
    // Only process stereo on desktop
    if (channels === 2) {
        const impulseR = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = length - i;
            const decay = Math.pow(n / length, 3 + (1 - intensity));
            impulseR[i] = (Math.random() * 2 - 1) * decay * intensity;
        }
    }
    
    convolverNode.buffer = impulse;
}

function setVolume(value) {
    masterVolume = parseInt(value) / 100;
    document.getElementById('volume-display').textContent = value + '%';
    
    // Update volume for Web Audio API if it exists
    if (gainNode) {
        gainNode.gain.value = masterVolume;
    }
}

function setReverbAmount(value) {
    reverbAmount = parseInt(value);
    document.getElementById('reverb-value').textContent = reverbAmount + '%';
}

function setDistortionAmount(value) {
    distortionAmount = parseInt(value);
    document.getElementById('distortion-value').textContent = distortionAmount + '%';
}

function toggleReverb() {
    const btn = document.getElementById('reverb-btn');
    const status = document.getElementById('status');
    
    reverbEnabled = !reverbEnabled;
    
    if (reverbEnabled) {
        btn.classList.add('active');
        status.textContent = 'Reverb: ON';
    } else {
        btn.classList.remove('active');
        status.textContent = 'Reverb: OFF';
    }
    
    setTimeout(() => {
        if (!isLooping && !isVoiceActive) status.textContent = 'Voice Standby';
        else if (isVoiceActive) status.textContent = 'Listening...';
    }, 2000);
}

function toggleDistortion() {
    const btn = document.getElementById('distortion-btn');
    const status = document.getElementById('status');
    
    distortionEnabled = !distortionEnabled;
    
    if (distortionEnabled) {
        btn.classList.add('active');
        status.textContent = 'Distortion: ON';
    } else {
        btn.classList.remove('active');
        status.textContent = 'Distortion: OFF';
    }
    
    setTimeout(() => {
        if (!isLooping && !isVoiceActive) status.textContent = 'Voice Standby';
        else if (isVoiceActive) status.textContent = 'Listening...';
    }, 2000);
}

function toggleLoop() {
    const btn = document.getElementById('loop-btn');
    const status = document.getElementById('status');
    
    if (isLooping) {
        // Stop loop
        isLooping = false;
        clearInterval(loopInterval);
        btn.textContent = 'Start Loop';
        btn.classList.remove('active');
        status.textContent = 'Loop Stopped';
    } else {
        // Start loop with drift compensation
        isLooping = true;
        lastBeatTime = Date.now();
        beatDrift = 0;
        
        playCurrentKick();
        
        const intervalTime = (60 / bpm) * 1000;
        
        loopInterval = setInterval(() => {
            const now = Date.now();
            const expectedTime = lastBeatTime + intervalTime;
            beatDrift = now - expectedTime;
            
            playCurrentKick();
            lastBeatTime = expectedTime; // Use expected time to prevent drift
        }, intervalTime);
        
        btn.textContent = 'Stop Loop';
        btn.classList.add('active');
        status.textContent = 'Looping at ' + bpm + ' BPM';
    }
}

function setTempo(value) {
    bpm = parseInt(value);
    document.getElementById('tempo-display').textContent = bpm;
    
    // If currently looping, restart with new tempo and reset drift
    if (isLooping) {
        clearInterval(loopInterval);
        lastBeatTime = Date.now();
        beatDrift = 0;
        
        const intervalTime = (60 / bpm) * 1000;
        
        loopInterval = setInterval(() => {
            const now = Date.now();
            const expectedTime = lastBeatTime + intervalTime;
            beatDrift = now - expectedTime;
            
            playCurrentKick();
            lastBeatTime = expectedTime;
        }, intervalTime);
        
        document.getElementById('status').textContent = 'Looping at ' + bpm + ' BPM';
    }
}

function showVoiceInstructions() {
    alert('Voice Commands:\n\n' +
        '• "Shuffle" or "Next" or "New kick" - Get a new kick sample\n' +
        '• "Play" or "Replay" or "Again" - Play current kick\n' +
        '• "Start loop" or "Loop" - Start looping\n' +
        '• "Stop loop" or "Stop looping" - Stop looping\n' +
        '• "Reverb" - Toggle reverb effect\n' +
        '• "Distortion" or "Distort" - Toggle distortion effect\n' +
        '• "Download" or "Save file" - Download current kick\n' +
        '• "Email" or "Send" - Email current kick\n' +
        '• "Tempo [number]" or "BPM [number]" - Set tempo (60-200)\n\n' +
        'Click the microphone button to start/stop voice control.');
}

function downloadKick() {
    if (!currentKick) {
        alert('Please shuffle a kick first!');
        return;
    }
    
    // Create a temporary link to download the audio file
    const link = document.createElement('a');
    link.href = currentKick;
    link.download = currentKick;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    const status = document.getElementById('status');
    status.textContent = 'Download Started';
    setTimeout(() => {
        if (!isLooping) status.textContent = isVoiceActive ? 'Listening...' : 'Voice Standby';
    }, 2000);
}

function sendEmail() {
    if (!currentKick) {
        alert('Please shuffle a kick first!');
        return;
    }
    
    // Ask for user's email
    const userEmail = prompt('Enter your email address:');
    
    if (!userEmail || !userEmail.includes('@')) {
        alert('Please enter a valid email address.');
        return;
    }
    
    const subject = encodeURIComponent('Kick Sample: ' + currentKick);
    const body = encodeURIComponent(
        `Hey!\n\nI found this awesome kick sample:\n\n${currentKick}\n\nFrom the Studio Brootle House Kick Sample Pack.\n\nLet me know what you think!`
    );
    
    // Create mailto link to user's own email
    window.location.href = `mailto:${userEmail}?subject=${subject}&body=${body}`;
    
    const status = document.getElementById('status');
    status.textContent = 'Opening email...';
    
    setTimeout(() => {
        if (!isLooping) status.textContent = isVoiceActive ? 'Listening...' : 'Voice Standby';
    }, 2000);
}

function toggleVoice() {
    const icon = document.getElementById('voice-icon');
    const status = document.getElementById('status');
    
    if (isVoiceActive) {
        // Stop voice recognition
        if (recognition) {
            recognition.stop();
        }
        isVoiceActive = false;
        icon.classList.remove('active');
        status.textContent = 'Voice Stopped';
    } else {
        // Check for microphone permissions first
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    // Permission granted, stop the stream and start speech recognition
                    stream.getTracks().forEach(track => track.stop());
                    startVoiceRecognition(icon, status);
                })
                .catch(function(err) {
                    alert('Microphone permission denied. Please allow microphone access in your browser settings and try again.');
                    console.error('Microphone permission error:', err);
                });
        } else {
            // Fallback for older browsers
            startVoiceRecognition(icon, status);
        }
    }
}

function startVoiceRecognition(icon, status) {
    // Start voice recognition
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('Voice recognition not supported in this browser. Please use Chrome or Edge.');
        return;
    }
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = false;
    recognition.lang = 'en-US';
    
    recognition.onstart = function() {
        isVoiceActive = true;
        icon.classList.add('active');
        status.textContent = 'Listening...';
    };
    
    recognition.onresult = function(event) {
        const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
        status.textContent = 'Heard: ' + transcript;
        
        // Voice commands
        if (transcript.includes('shuffle') || transcript.includes('next') || transcript.includes('new kick')) {
            shuffleKick();
        } else if (transcript.includes('play') || transcript.includes('replay') || transcript.includes('again')) {
            playCurrentKick();
        } else if (transcript.includes('start loop') || transcript.includes('loop')) {
            if (!isLooping) toggleLoop();
        } else if (transcript.includes('stop loop') || transcript.includes('stop looping')) {
            if (isLooping) toggleLoop();
        } else if (transcript.includes('download') || transcript.includes('save file')) {
            downloadKick();
        } else if (transcript.includes('reverb')) {
            toggleReverb();
        } else if (transcript.includes('distortion') || transcript.includes('distort')) {
            toggleDistortion();
        } else if (transcript.includes('email') || transcript.includes('send')) {
            sendEmail();
        } else if (transcript.includes('tempo') || transcript.includes('speed') || transcript.includes('bpm')) {
            // Extract number from command
            const numbers = transcript.match(/\d+/);
            if (numbers) {
                const newBpm = parseInt(numbers[0]);
                if (newBpm >= 60 && newBpm <= 200) {
                    document.getElementById('tempo-slider').value = newBpm;
                    setTempo(newBpm);
                }
            }
        }
        
        setTimeout(() => {
            if (isVoiceActive && !isLooping) status.textContent = 'Listening...';
        }, 2000);
    };
    
    recognition.onerror = function(event) {
        console.error('Speech recognition error:', event.error);
        status.textContent = 'Error: ' + event.error;
        setTimeout(() => {
            if (isVoiceActive) status.textContent = 'Listening...';
        }, 2000);
    };
    
    recognition.onend = function() {
        if (isVoiceActive) {
            recognition.start(); // Restart if still active
        }
    };
    
    recognition.start();
}

// Initialize with random kick on page load
window.addEventListener('load', function() {
    const fileText = document.getElementById('filename');
    currentKick = kickLibrary[Math.floor(Math.random() * kickLibrary.length)];
    fileText.textContent = currentKick.toUpperCase();
}, { passive: true });
    </script>
</body>
</html>